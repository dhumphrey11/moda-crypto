## Goal

Generate a complete mono-repo for a personal crypto signal & paper-trading app named **`moda-crypto`**. The repo will contain a **FastAPI** backend, **Next.js (TypeScript)** frontend, CI/CD workflows for Firebase Cloud Run / Firebase Hosting, Dockerfiles, and example cron scripts. The stack uses Firestore for storage and Firebase Authentication (frontend only). The ML baseline uses **scikit-learn** and models are saved to Firebase Storage. The app is a single-user system (the developer).

Produce runnable code, scaffolding, and necessary config files so that a developer can open the project in VS Code and run it locally (with valid API keys in `.env`) and deploy to GCP/Firebase. Use best practices: modular code, comments, README instructions, and a `.env.example` file with placeholders. Do NOT include any real API keys or private credentials.

---

## High-level Requirements (to include in generated repo)

1. Mono-repo root name: `moda-crypto`
2. Two top-level folders: `/backend` and `/frontend`.
3. Backend: FastAPI app (single service) with routers for `fetch`, `compute`, `paper-trade`, `admin`, health endpoint; feature engineering, model training/prediction (scikit-learn), Firestore client integration, and services for CoinGecko, Moralis, Covalent, LunarCrush, CoinMarketCal, CryptoPanic, Coinbase Advanced.
4. Frontend: Next.js + TypeScript + Tailwind CSS + shadcn/radix components (or similar) with pages: Dashboard, Signals, Portfolio, Admin, Token Detail. Use simple polling to refresh data (60s). Use Firebase auth to sign in (single-user flow ok) and Firestore read-only subscriptions.
5. Firestore: flat collections design: tokens, features, signals, trades, models, adminConfig, runs, events, portfolio.
6. .env.example with placeholders for all API keys and Firebase credentials; `.env` must be ignored via `.gitignore`.
7. Dockerfile for backend; Dockerfile or build config for frontend; GitHub Actions workflows for `frontend-deploy.yml` (Firebase Hosting) and `backend-deploy.yml` (Cloud Run). Include `infra/cron/cronjobs.txt` with curl commands for scheduled job hits.
8. Provide `backend/requirements.txt` and simple virtualenv instructions; frontend `package.json` and `tsconfig.json`.
9. Implement a simple `train.py` (scikit-learn XGBoost or RandomForest) with placeholder dataset generation if real features missing; training job saves model to `models/` and uploads artifact to Firebase Storage (or writes metadata to Firestore `models` collection).
10. Implement `feature_engineer.py` that reads raw market/on-chain/social from services and writes normalized features to Firestore `features` collection.
11. Implement `predict.py` which loads the model artifact and computes `ml_prob` for tokens; compute `rule_score`, `sentiment_score`, `event_score`, and composite `composite_score`. Use admin-config weights from Firestore `adminConfig`.
12. Paper-trade executor: `paper-trade/executor.py` that reads signals with `composite_score >= 0.85` and applies trade rules: min liquidity ($50k), max per-trade allocation 10% of cash, max total allocation 15% per token, one open position per token. Updates `trades` and `portfolio` collections in Firestore.
13. System health: After each cron-run endpoint, write a `runs` document with `{ service, ts, status, count }`. Implement `/health` endpoint that aggregates last run statuses. UI reads `/health` and shows system health panel.
14. Weekly retrain: `admin/retrain` endpoint which triggers training and writes `models` doc and run log. Cron entry to call weekly retrain.
15. Logging: backend writes debug logs locally and writes minimal run stats into Firestore `runs`.

---

## Detailed Code & File Requirements

### Repo root files

* `README.md` with setup, local dev, run, and deploy steps.
* `.gitignore` (exclude `.env`, `*.pyc`, `__pycache__`, `node_modules`, `.next`, `dist`, `.firebase`, etc.)
* `.env.example` with placeholders for all keys below.
* `infra/cron/cronjobs.txt` with curl lines.

### Backend (folder: `/backend`)

* `Dockerfile` and instructions for Cloud Run.
* `requirements.txt` (fastapi, uvicorn, google-cloud-firestore, firebase-admin, scikit-learn, xgboost, joblib, pydantic, python-dotenv, requests, google-cloud-storage)
* `app/main.py` (FastAPI app, include routers and startup events to init Firestore client.)
* `app/routers/fetch.py` with endpoints:

  * `/fetch/coingecko`, `/fetch/moralis`, `/fetch/covalent`, `/fetch/lunarcrush`, `/fetch/coinmarketcal`, `/fetch/cryptopanic` — each should call the corresponding `services/*` module and write raw data and a `runs` log entry.
* `app/routers/compute.py` with endpoint `POST /compute/signals` that triggers feature engineering and prediction flow for all tokens in `tokens` collection and writes `signals` docs.
* `app/routers/trade.py` with endpoint `POST /paper-trade` that checks for new signals ≥0.85 and executes paper trades.
* `app/routers/admin.py` with endpoint `POST /admin/retrain` that triggers model training.
* `app/services/*.py` (coingecko.py, moralis.py, covalent.py, lunarcrush.py, coinmarketcal.py, cryptopanic.py, coinbase.py) — wrappers that call external APIs and return parsed JSON. Use placeholder URLs and implement rate limiting handling and retries.
* `app/firestore_client.py` — initialize Firebase Admin and Firestore client using env vars. Provide helper functions: `write_run(service, count, status)`, `write_features`, `write_signal`, `write_trade`, `get_tokens_list`, `get_admin_config`, `get_portfolio`.
* `app/features/feature_engineer.py` — compute TA (using pandas), on-chain aggregates, sentiment aggregates, event proximity. For simplicity, compute features for last available timestamp and write to `features` collection.
* `app/models/train.py` — read `features` and `signals` (label generator), train XGBoost/RandomForest, write model artifact to local `models/` dir and upload to Firebase Storage; write metadata to Firestore `models` collection.
* `app/models/predict.py` — load latest model and predict probabilities for tokens.
* `app/paper_trade/executor.py` — implement trade-rule checks and Firestore updates.
* `app/config.py` — pydantic settings reading `.env`.

### Frontend (folder: `/frontend`)

* Next.js + TypeScript app scaffold.
* Tailwind CSS setup.
* Pages: `index.tsx` (dashboard), `signals.tsx`, `portfolio.tsx`, `admin.tsx`.
* `lib/firestore.ts` — helper to read from Firestore using Firebase Web SDK. Implement simple polling (every 60s) to refresh signals and portfolio.
* Components: `SignalCard`, `PortfolioTable`, `HealthPanel`, `TokenDetailModal`.
* Use Firebase Auth for sign-in (single user). Provide login page that authenticates and stores token in local storage.

### CI/CD & Infra

* `infra/github-actions/frontend-deploy.yml` — build Next.js and deploy to Firebase Hosting.
* `infra/github-actions/backend-deploy.yml` — build Docker image and deploy to Cloud Run using `gcloud` (assume GCP project set in secrets).
* `infra/cron/cronjobs.txt` — example cron entries using `curl` to call your backend endpoints.

---

## .env.example (placeholders)

```
# Firebase
FIREBASE_PROJECT_ID=your-firebase-project-id
FIREBASE_CLIENT_EMAIL=your-client-email@project.iam.gserviceaccount.com
FIREBASE_PRIVATE_KEY=<INSERT_YOUR_FIREBASE_PRIVATE_KEY_HERE>

# API Keys (placeholders)
COINGECKO_API_KEY=<COINGECKO_API_KEY>
MORALIS_API_KEY=<MORALIS_API_KEY>
COVALENT_API_KEY=<COVALENT_API_KEY>
LUNARCRUSH_API_KEY=<LUNARCRUSH_API_KEY>
COINMARKETCAL_API_KEY=<COINMARKETCAL_API_KEY>
CRYPTOPANIC_API_KEY=<CRYPTOPANIC_API_KEY>
COINBASE_API_KEY=<COINBASE_API_KEY>

# Other
FIREBASE_STORAGE_BUCKET=your-firebase-storage-bucket
GOOGLE_APPLICATION_CREDENTIALS=path/to/service-account.json
```

---

## Security & Git

* Add `.env` and service account JSON to `.gitignore`.
* In the README, instruct the user to never commit keys. Use GCP Secret Manager and GitHub Secrets for CI.

---

## Developer Experience & Commands

Provide NPM and Python scripts in `package.json` and `Makefile`:

* `npm run dev` (frontend)
* `npm run build` / `npm run start` (frontend)
* `python -m uvicorn app.main:app --reload` (backend dev)
* `docker build -t moda-crypto-backend ./backend` (docker build)
* `gcloud run deploy moda-crypto-backend --image gcr.io/$PROJECT_ID/moda-crypto-backend` (deploy)

---

## README sections to include

1. Project overview & architecture diagram (ASCII or simple image placeholders)
2. Local dev setup (prereqs, `.env`, Firebase credentials, how to run backend & frontend)
3. Firestore collections & key fields (flat schema)
4. Cron setup instructions (how to deploy cron jobs or use Cloud Scheduler)
5. CI/CD instructions (GitHub Actions secrets required)
6. How to retrain models locally and where artifacts are stored
7. Notes on security and next steps

---

## Output this prompt to a `.txt` file

Please create a single text file named: `copilot_prompt_moda-crypto.txt` containing this entire prompt. The file should be ready to paste into GitHub Copilot or Copilot Labs in VS Code. DO NOT include any real or private credentials inside the prompt—use placeholders as above.

---

### Final notes to the generator

* The generated code should be functional and runnable after the user inserts valid API keys into `.env` and configures GCP/Firebase project.
* Keep the initial model and feature code simple and well-commented so the developer (single user) can iterate.
* Include TODO comments where a developer should add production-grade improvements (security, rate-limiting, retries, error handling, test coverage).

Thank you — generate the full repo scaffolding, configs, and starter code as described above.